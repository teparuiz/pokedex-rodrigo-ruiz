"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/next/node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/next/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"./node_modules/next/node_modules/@swc/helpers/esm/_create_class.js\");\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"./node_modules/next/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"./node_modules/next/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/next/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"./node_modules/next/node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default() {\n        return Router;\n    },\n    matchesMiddleware: function matchesMiddleware1() {\n        return matchesMiddleware;\n    },\n    createKey: function createKey1() {\n        return createKey;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/next/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/next/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"./node_modules/next/dist/client/resolve-href.js\");\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator._(function(options) {\n        var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname;\n                    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n                    cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(router, url, true), 2), resolvedHref = _ref[0], resolvedAs = _ref[1];\n    var origin = (0, _utils.getLocationOrigin)();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(function(param) {\n                var _param = _sliced_to_array._(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsepath.parsePath)(source);\n        var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        })), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsepath.parsePath)(redirectTarget);\n            var pathname1 = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            })), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname1 + src1.query + src1.hash,\n                newUrl: \"\" + pathname1 + src1.query + src1.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator._(function(options) {\n        var matches, data, effect, e;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var _params_method;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        })[\"catch\"](function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname, query, as, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _class_call_check._(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var _$pathname = _this.pathname, _$query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(_$pathname),\n                    query: _$query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, _$as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var _$pathname1 = (0, _parserelativeurl.parseRelativeUrl)(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && _$as === (0, _addbasepath.addBasePath)(_this.asPath) && _$pathname1 === (0, _addbasepath.addBasePath)(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, _$as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\").BloomFilter);\n            var staticFilterData = {\"numItems\":1,\"errorRate\":0.0001,\"numBits\":20,\"numHashes\":14,\"bitArray\":[1,0,0,0,0,1,1,0,1,0,0,1,0,1,0,1,1,1,1,0]};\n            var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.0001,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s[\"import\"](staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d[\"import\"](dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname,\n            query: query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as !== pathname;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query: query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _create_class._(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Go forward in history\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, options) {\n                if (options === void 0) options = {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, options) {\n                if (options === void 0) options = {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale, skipNavigate) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i1, _iter1, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n                    return _ts_generator._(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            // if any sub-path of as matches a dynamic filter path\n                                            // it should be hard navigated\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            if (skipNavigate) {\n                                                return [\n                                                    2,\n                                                    true\n                                                ];\n                                            }\n                                            handleHardNavigation({\n                                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2,\n                            false\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref, ref1, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _routeInfo_route, isValidShallowRoute, _options_scroll1, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1, err2, canSkipUpdating, e, hashRegex, err3;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _islocalurl.isLocalURL)(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                // WARNING: `_h` is an internal option for handing Next.js client-side\n                                // hydration. Your app should _never_ use this property. It may change at\n                                // any time without notice.\n                                isQueryUpdating = options._h === 1;\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                                nextState = _object_spread._({}, _this.state);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                // or a navigation has occurred\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _object_spread_props._(_object_spread._({}, options), {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _iserror[\"default\"])(err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeloader.getClientBuildManifest)(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref = _sliced_to_array._.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref[0], ref1 = ref[1], rewrites = ref1.__rewrites, ref1, ref;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                // we need to resolve the as value using rewrites for dynamic SSG\n                                // pages to allow building the data URL correctly\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                                // if we detected the path as app route during prefetching\n                                // trigger hard navigation\n                                if ((_this_components_pathname = _this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formaturl.formatWithValidation)(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _islocalurl.isLocalURL)(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                routeMatch = false;\n                                if ((0, _isdynamic.isDynamicRoute)(route)) {\n                                    parsedAs1 = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeregex.getRouteRegex)(route);\n                                    routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit.omit)(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                                            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeregex.getRouteRegex)(pathname);\n                                        curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script.handleClientScriptLoad)(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isNotFound: true\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                // shallow routing is only allowed for same page URL changes.\n                                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                                shouldScroll = (_options_scroll1 = options.scroll) != null ? _options_scroll1 : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                // the new state that the router gonna set\n                                upcomingRouterState = _object_spread_props._(_object_spread._({}, nextState), {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \" + _this.pathname);\n                                }\n                                if (_this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                // for query updates we can skip it if the state is unchanged and we don't\n                                // need to scroll\n                                // https://github.com/vercel/next.js/issues/37139\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                // A hash mark # is the optional last part of a URL\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err3 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err3) && err3.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err3;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, options) {\n                if (options === void 0) options = {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\" + method + \" is not available\");\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror[\"default\"])(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                                /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formaturl.formatWithValidation)({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    })[\"catch\"](function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                // when rendering error routes we don't apply middleware\n                                // effects\n                                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                                    data.effect = undefined;\n                                }\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _object_spread_props._(_object_spread._({}, existingInfo), {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isapiroute.isAPIRoute)(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(/*#__PURE__*/ _async_to_generator._(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _ts_generator._(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formaturl.formatWithValidation)({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _sliced_to_array._(this.asPath.split(\"#\", 2), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _sliced_to_array._(as.split(\"#\", 2), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _sliced_to_array._(as.split(\"#\", 2), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                    // Scroll to top if the hash is just `#` with no value or `#top`\n                    // To mirror browsers\n                    if (hash === \"\" || hash === \"top\") {\n                        window.scrollTo(0, 0);\n                        return;\n                    }\n                    // Decode hash to make non-latin anchor works.\n                    var rawHash = decodeURIComponent(hash);\n                    // First we check if the element by id is found\n                    var idEl = document.getElementById(rawHash);\n                    if (idEl) {\n                        idEl.scrollIntoView();\n                        return;\n                    }\n                    // If there's no element with the id, we check the `name` property\n                    // To mirror browsers\n                    var nameEl = document.getElementsByName(rawHash)[0];\n                    if (nameEl) {\n                        nameEl.scrollIntoView();\n                    }\n                }, {\n                    onlyHashChange: this.onlyAHashChange(as)\n                });\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, asPath, options) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (asPath === void 0) asPath = url;\n                                if (options === void 0) options = {};\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                urlPathname = parsed.pathname;\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeloader.getClientBuildManifest)()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formaturl.formatWithValidation)({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formaturl.formatWithValidation)(parsed);\n                                }\n                                /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                return [\n                                    4,\n                                    _this._bfl(asPath, resolvedAs, options.locale, true)\n                                ];\n                            case 8:\n                                if (_state.sent()) {\n                                    _this.components[urlPathname] = {\n                                        __appRouter: true\n                                    };\n                                }\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            })[\"catch\"](function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 9:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var handleCancelled, componentResult, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils.loadGetInitialProps)(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt[\"default\"])(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFDZjs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLFdBQVMsU0FBVEE7UUFDSSxPQUFPUztJQUNYO0lBQ0FSLG1CQUFtQixTQUFuQkE7UUFDSSxPQUFPQTtJQUNYO0lBQ0FDLFdBQVcsU0FBWEE7UUFDSSxPQUFPQTtJQUNYO0FBQ0o7QUFDQSxJQUFNUSwyQkFBMkJDLG1CQUFPQSxDQUFDLDhIQUF5QztBQUNsRixJQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLGdJQUEwQztBQUNwRixJQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdIQUErQjtBQUNwRSxJQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxxRkFBOEI7QUFDM0QsSUFBTUksVUFBVUosbUJBQU9BLENBQUMseUVBQXdCO0FBQ2hELElBQU1LLFdBQVcsV0FBVyxHQUFHSiwwQkFBMEJLLENBQUMsQ0FBQ04sbUJBQU9BLENBQUMsdUVBQXVCO0FBQzFGLElBQU1PLHVCQUF1QlAsbUJBQU9BLENBQUMsa0hBQW9DO0FBQ3pFLElBQU1RLHVCQUF1QlIsbUJBQU9BLENBQUMsd0dBQStCO0FBQ3BFLElBQU1TLFFBQVEsV0FBVyxHQUFHVix5QkFBeUJPLENBQUMsQ0FBQ04sbUJBQU9BLENBQUMsNERBQVM7QUFDeEUsSUFBTVUsU0FBU1YsbUJBQU9BLENBQUMsOERBQVU7QUFDakMsSUFBTVcsYUFBYVgsbUJBQU9B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QzdGLEtBQUs7WUFDM0I7OztZQUNJeEUsS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNxSyxLQUFLLENBQUNySyxNQUFNO1lBQzVCOzs7WUFDSU0sS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUMrSixLQUFLLENBQUMvSixNQUFNO1lBQzVCOzs7WUFDSXVKLEtBQUFBO2lCQUFKO2dCQUNJLE9BQU8sSUFBSSxDQUFDUSxLQUFLLENBQUNSLFVBQVU7WUFDaEM7OztZQUNJRSxLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQ00sS0FBSyxDQUFDTixTQUFTO1lBQy9COzs7V0F0bUNFbE47O0FBK3hDTkEsT0FBT2dRLE1BQU0sR0FBRyxDQUFDLEdBQUdyUCxLQUFNcEIsQ0FBQUEsVUFBTyxLQUVqQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IG51bGwsXG4gICAgY3JlYXRlS2V5OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVyO1xuICAgIH0sXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc01pZGRsZXdhcmU7XG4gICAgfSxcbiAgICBjcmVhdGVLZXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9yZW1vdmV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgX3JvdXRlbG9hZGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXJcIik7XG5jb25zdCBfc2NyaXB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9zY3JpcHRcIik7XG5jb25zdCBfaXNlcnJvciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtZXJyb3JcIikpO1xuY29uc3QgX2Rlbm9ybWFsaXplcGFnZXBhdGggPSByZXF1aXJlKFwiLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbmNvbnN0IF9ub3JtYWxpemVsb2NhbGVwYXRoID0gcmVxdWlyZShcIi4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpO1xuY29uc3QgX21pdHQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xuY29uc3QgX3BhcnNlcmVsYXRpdmV1cmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG5jb25zdCBfcmVzb2x2ZXJld3JpdGVzID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLXJld3JpdGVzXCIpKTtcbmNvbnN0IF9yb3V0ZW1hdGNoZXIgPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1tYXRjaGVyXCIpO1xuY29uc3QgX3JvdXRlcmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX2RldGVjdGRvbWFpbmxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIik7XG5jb25zdCBfcGFyc2VwYXRoID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWJhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGJhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xuY29uc3QgX2dldG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2lzYm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKFwiUm91dGUgQ2FuY2VsbGVkXCIpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcbiAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShvcHRpb25zLmFzUGF0aCk7XG4gICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXNQYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWU7XG4gICAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpKTtcbiAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pPT5uZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKSk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfZGVub3JtYWxpemVwYWdlcGF0aC5kZW5vcm1hbGl6ZVBhZ2VQYXRoKShwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSBcIi80MDRcIiB8fCBjbGVhblBhdGhuYW1lID09PSBcIi9fZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZXdyaXRlXCIpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLW1hdGNoZWQtcGF0aFwiKTtcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tYXRjaGVkLXBhdGhcIik7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIl9fbmV4dF9kYXRhX2NhdGNoYWxsXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi9fZXJyb3JcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiLzQwNFwiKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBsZXQgYXMgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKSgoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoc291cmNlKS5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZzogcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyA/IHVuZGVmaW5lZCA6IG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkU291cmNlLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KShhcywgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCAocGF0aCk9PnJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IHJlc3VsdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgcmVzdWx0LnBhcnNlZEFzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKGZzUGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUGF0aG5hbWUgIT09IGZzUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSA/IHJlc29sdmVEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSwgcGFnZXMpIDogZnNQYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJlc29sdmVkSHJlZikpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXdyaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWRSZXdyaXRlVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShzb3VyY2UpO1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGJ1aWxkSWQ6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtcmVkaXJlY3RcIik7XG4gICAgaWYgKHJlZGlyZWN0VGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZWRpcmVjdFRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShyZWRpcmVjdFRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XG4gICAgICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIGJ1aWxkSWQ6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1pbnRlcm5hbFwiLFxuICAgICAgICAgICAgICAgIG5ld0FzOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaCxcbiAgICAgICAgICAgICAgICBuZXdVcmw6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiByZWRpcmVjdFRhcmdldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHR5cGU6IFwibmV4dFwiXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoTWlkZGxld2FyZUVmZmVjdHMob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKTtcbiAgICBpZiAoIW1hdGNoZXMgfHwgIW9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgb3B0aW9ucy5mZXRjaERhdGEoKTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgZ2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcbiAgICAgICAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgICAgICAgICAgdGV4dDogZGF0YS50ZXh0LFxuICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgICAgICBlZmZlY3RcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAqIFRPRE86IFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cbiAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAqLyByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInNjcm9sbFJlc3RvcmF0aW9uXCIgaW4gd2luZG93Lmhpc3RvcnkgJiYgISFmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdiA9IFwiX19uZXh0XCI7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbChcIlNTR19EQVRBX05PVF9GT1VORFwiKTtcbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cywgb3B0aW9ucykge1xuICAgIHJldHVybiBmZXRjaCh1cmwsIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgIFwieC1uZXh0anMtZGF0YVwiOiBcIjFcIlxuICAgICAgICB9KVxuICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICByZXR1cm4gIXJlc3BvbnNlLm9rICYmIGF0dGVtcHRzID4gMSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwID8gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSwgb3B0aW9ucykgOiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRyeVRvUGFyc2VBc0pTT04odGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEocGFyYW0pIHtcbiAgICBsZXQgeyBkYXRhSHJlZiwgaW5mbGlnaHRDYWNoZSwgaXNQcmVmZXRjaCwgaGFzTWlkZGxld2FyZSwgaXNTZXJ2ZXJSZW5kZXIsIHBhcnNlSlNPTiwgcGVyc2lzdENhY2hlLCBpc0JhY2tncm91bmQsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB9ID0gcGFyYW07XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciBfcGFyYW1zX21ldGhvZDtcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PmZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XG4gICAgICAgICAgICAgICAgcHVycG9zZTogXCJwcmVmZXRjaFwiXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICBcIngtbWlkZGxld2FyZS1wcmVmZXRjaFwiOiBcIjFcIlxuICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgIG1ldGhvZDogKF9wYXJhbXNfbWV0aG9kID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gX3BhcmFtc19tZXRob2QgOiBcIkdFVFwiXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJ5VG9QYXJzZUFzSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RyeVRvUGFyc2VBc0pTT04gPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RyeVRvUGFyc2VBc0pTT04ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzXCIpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIGNocm9tZVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgLy8gZmlyZWZveFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIiB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAgIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAgIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShpc0JhY2tncm91bmQgPyB7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCJcbiAgICB9IDoge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHVybCwgcm91dGVyIH0gPSBwYXJhbTtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUsIHJvdXRlciB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicHVzaFN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgICh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzXG4gICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoY3VyQXMsIFwiaHR0cDovL25cIikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc05vU2xhc2ggIT09ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5jb250YWlucyhjdXJyZW50UGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmwpKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIiArIGRldGVjdGVkRG9tYWluLmRvbWFpbiArICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKFwiXCIgKyAobmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gXCIvXCIgPyBcIlwiIDogYXNOb0Jhc2VQYXRoKSB8fCBcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSwgc2Nyb2xsID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcInJlcGxhY2VTdGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aChcIi9cIikgJiYgKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgLy8gaWYgd2UgZGV0ZWN0ZWQgdGhlIHBhdGggYXMgYXBwIHJvdXRlIGR1cmluZyBwcmVmZXRjaGluZ1xuICAgICAgICAvLyB0cmlnZ2VyIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICBpZiAoKF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUgPSB0aGlzLmNvbXBvbmVudHNbcGF0aG5hbWVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfY29tcG9uZW50c19wYXRobmFtZS5fX2FwcFJvdXRlcikge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiSW50ZXJwb2xhdGluZyBocmVmXCIgOiBcIk1pc21hdGNoaW5nIGBhc2AgYW5kIGBocmVmYFwiKSArIFwiIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIFwiICsgKFwidGhlIHBhcmFtczogXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9yb3V0ZUluZm9fcHJvcHM7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJvdXRlXCIgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdC5oYW5kbGVDbGllbnRTY3JpcHRMb2FkKShzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvX2Vycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlSW5mb19yb3V0ZSA9IHJvdXRlSW5mby5yb3V0ZSkgIT0gbnVsbCA/IF9yb3V0ZUluZm9fcm91dGUgOiByb3V0ZSk7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3JvdXRlSW5mb19wcm9wczE7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICBcIlwiLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFwiL19lcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6IFwiLCBnaXBFcnIpO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5kZWZhdWx0KShyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArIFwiXCIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZUluZm8ocGFyYW0pIHtcbiAgICAgICAgbGV0IHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzLCBsb2NhbGUsIGhhc01pZGRsZXdhcmUsIGlzUHJldmlldywgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLCBpc1F1ZXJ5VXBkYXRpbmcsIGlzTWlkZGxld2FyZVJld3JpdGUsIGlzTm90Rm91bmQgfSA9IHBhcmFtO1xuICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9kYXRhX2VmZmVjdCwgX2RhdGFfZWZmZWN0MSwgX2RhdGFfZWZmZWN0MiwgX2RhdGFfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgIShcImluaXRpYWxcIiBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmc7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdCA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWludGVybmFsXCIgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNhcGlyb3V0ZS5pc0FQSVJvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBwYXRobmFtZSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX3Jlc3BvbnNlID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLXNraXBcIik7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBjYWNoZUtleSB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiY1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdChcIiNcIiwgMik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoXCIjXCIsIDIpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIiwgMik7XG4gICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb25seUhhc2hDaGFuZ2U6IHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYXNQYXRoID09PSB2b2lkIDApIGFzUGF0aCA9IHVybDtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoMCwgX2lzYm90LmlzQm90KSh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcbiAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSBcInN0cmljdFwiID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9iZmwoYXNQYXRoLCByZXNvbHZlZEFzLCBvcHRpb25zLmxvY2FsZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1t1cmxQYXRobmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgX19hcHBSb3V0ZXI6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU3NnID8gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHwgb3B0aW9ucy5wcmlvcml0eSAmJiAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKCk9PmZhbHNlKS5jYXRjaCgoKT0+ZmFsc2UpIDogZmFsc2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gXCJsb2FkUGFnZVwiIDogXCJwcmVmZXRjaFwiXShyb3V0ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZSBSU0MgZmxpZ2h0IHJlc3BvbnNlIHNpbmNlIGl0J3Mgbm90IGEgc3RhdGljIHJlc291cmNlXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcbiAgICAgICAgfSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcywgcGFnZUxvYWRlciwgQXBwLCB3cmFwQXBwLCBDb21wb25lbnQsIGVyciwgc3Vic2NyaXB0aW9uLCBpc0ZhbGxiYWNrLCBsb2NhbGUsIGxvY2FsZXMsIGRlZmF1bHRMb2NhbGUsIGRvbWFpbkxvY2FsZXMsIGlzUHJldmlldyB9KXtcbiAgICAgICAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcbiAgICAgICAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2JjID0ge307XG4gICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9rZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgICAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJiBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBrZXkgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvYmxvb20tZmlsdGVyXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUjtcbiAgICAgICAgICAgIGlmIChzdGF0aWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNGaWx0ZXJEYXRhLm51bUhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zID0gbmV3IEJsb29tRmlsdGVyKHN0YXRpY0ZpbHRlckRhdGEubnVtSXRlbXMsIHN0YXRpY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGR5bmFtaWNGaWx0ZXJEYXRhLm51bUhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKGR5bmFtaWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBkeW5hbWljRmlsdGVyRGF0YS5lcnJvclJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmlzRXhwZXJpbWVudGFsQ29tcGlsZSB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXNQYXRoOiBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXMsXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRoID0gKDAsIF91dGlscy5nZXRVUkwpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5Sb3V0ZXIuZXZlbnRzID0gKDAsIF9taXR0LmRlZmF1bHQpKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0IiwibWF0Y2hlc01pZGRsZXdhcmUiLCJjcmVhdGVLZXkiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiX3JvdXRlbG9hZGVyIiwiX3NjcmlwdCIsIl9pc2Vycm9yIiwiXyIsIl9kZW5vcm1hbGl6ZXBhZ2VwYXRoIiwiX25vcm1hbGl6ZWxvY2FsZXBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc2R5bmFtaWMiLCJfcGFyc2VyZWxhdGl2ZXVybCIsIl9yZXNvbHZlcmV3cml0ZXMiLCJfcm91dGVtYXRjaGVyIiwiX3JvdXRlcmVnZXgiLCJfZm9ybWF0dXJsIiwiX2RldGVjdGRvbWFpbmxvY2FsZSIsIl9wYXJzZXBhdGgiLCJfYWRkbG9jYWxlIiwiX3JlbW92ZWxvY2FsZSIsIl9yZW1vdmViYXNlcGF0aCIsIl9hZGRiYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9yZXNvbHZlaHJlZiIsIl9pc2FwaXJvdXRlIiwiX2dldG5leHRwYXRobmFtZWluZm8iLCJfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyIsIl9jb21wYXJlc3RhdGVzIiwiX2lzbG9jYWx1cmwiLCJfaXNib3QiLCJfb21pdCIsIl9pbnRlcnBvbGF0ZWFzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJtYXRjaGVycyIsImFzUGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJwYXRobmFtZSIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwicGFyYW0iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInVuZGVmaW5lZCIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZGF0YSIsImVmZmVjdCIsImUiLCJmZXRjaERhdGEiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiX3BhcmFtc19tZXRob2QiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJpbml0aWFsUHJvcHMiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJzZGMiLCJzYmMiLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIl9rZXkiLCJvblBvcFN0YXRlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwiX2JmbF9zIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImlzRXhwZXJpbWVudGFsQ29tcGlsZSIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwicmVwbGFjZSIsIl9iZmwiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsIl90aGlzX19iZmxfczEiLCJub3JtYWxpemVkQVMiLCJjdXJBc1BhcnRzIiwiaSIsIl90aGlzX19iZmxfZCIsImN1cnJlbnRQYXJ0IiwiY29udGFpbnMiLCJzcGxpdCIsImpvaW4iLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiaXNRdWVyeVVwZGF0aW5nIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImFzTm9CYXNlUGF0aCIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWQiLCJwYXJzZWRBc1BhdGhuYW1lIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJtaXNzaW5nUGFyYW1zIiwiaXNFcnJvclJvdXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzIiwiX3JvdXRlSW5mb19wcm9wcyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50Iiwic2NyaXB0cyIsInBhcnNlZEhyZWYiLCJub3RGb3VuZFJvdXRlIiwiX3JvdXRlSW5mb19yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfb3B0aW9uc19zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImhhc2hSZWdleCIsImlzTG9jYWxVUkwiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsInVybElzTmV3IiwiX19hcHBSb3V0ZXIiLCJwIiwiZXh0ZXJuYWxEZXN0IiwiaW50ZXJwb2xhdGVBcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImdldFJvdXRlSW5mbyIsImZvckVhY2giLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsIl9fTl9QUkVWSUVXIiwiZmV0Y2hDb21wb25lbnQiLCJpc05vdEZvdW5kIiwic3RhdHVzQ29kZSIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJyZXF1ZXN0ZWRSb3V0ZSIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwiX2RhdGFfcmVzcG9uc2UiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwicmVzb2x2ZWRSb3V0ZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvbmx5SGFzaENoYW5nZSIsInByZWZldGNoIiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiX2dldEZsaWdodERhdGEiLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});